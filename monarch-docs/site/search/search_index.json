{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MONARCH is an open-source Python package to rapidly model cardiac physiology and remodeling. It is developed by the BEAT Lab at UCI directed by Pim Oomen. MONARCH stands for Model for Open-source Numerical simulations of Arrhythmia, Remodeling, Cardiac mechanics, and Hypertrophy. Installation Virtual environment It is recommended to install MONARCH in a virtual environment. To create a virtual environment using Conda, first install a distribution of Anaconda or Miniconda . After installation, open a terminal window to create a new virtual environment named (for example) monarch that uses Python 3.12 : conda create -n monarch python=3.12 conda activate monarch Installing using pip (not yet available) MONARCH can be installed using pip: pip install monarch-beatlab Installing from source Download the latest source code from Github. From a terminal window in the directory where you want to download and install the MONARCH source code, run: git clone https://github.com/BeatLabUCI/monarch.git Then build and install MONARCH from the top level of the source tree: pip install . Checking your installation To check that MONARCH has been installed correctly, open a Python interpreter (with the correct virtual environment if applicable) and run: import monarch Using Monarch We include several Jupyter notebooks to demonstrate how to use MONARCH. These notebooks can be found on separate tabs on this webpage!","title":"Home"},{"location":"#installation","text":"","title":"Installation"},{"location":"#virtual-environment","text":"It is recommended to install MONARCH in a virtual environment. To create a virtual environment using Conda, first install a distribution of Anaconda or Miniconda . After installation, open a terminal window to create a new virtual environment named (for example) monarch that uses Python 3.12 : conda create -n monarch python=3.12 conda activate monarch","title":"Virtual environment"},{"location":"#installing-using-pip-not-yet-available","text":"MONARCH can be installed using pip: pip install monarch-beatlab","title":"Installing using pip (not yet available)"},{"location":"#installing-from-source","text":"Download the latest source code from Github. From a terminal window in the directory where you want to download and install the MONARCH source code, run: git clone https://github.com/BeatLabUCI/monarch.git Then build and install MONARCH from the top level of the source tree: pip install .","title":"Installing from source"},{"location":"#checking-your-installation","text":"To check that MONARCH has been installed correctly, open a Python interpreter (with the correct virtual environment if applicable) and run: import monarch","title":"Checking your installation"},{"location":"#using-monarch","text":"We include several Jupyter notebooks to demonstrate how to use MONARCH. These notebooks can be found on separate tabs on this webpage!","title":"Using Monarch"},{"location":"growth/","text":"Simulating growth The true strength of this package is in its ability to simulate cardiac growth. This notebook will guide you through the process of simulating cardiac growth using a canine model with mitral valve regurgitation as an example. We recommend to first familiarize yourself with the single beat simulations in the single_beat.ipynb notebook before proceeding. Background Mechanics-based growth models We included several mechanics-based growth relationships based on reference [1-4]. The choice of growth model is up to the user and can be specified in the input file in growth.type . We use the kinematic growth model framework from Rodriguez et al. [5]. In brief, the way that all these models work is that they compare the current state of mechanics (typically elastic stretch) in each cardiac wall patch to that of a previous state. The growth model then calculates the amount of growth based on the difference between these states. The growth tensor F_g for each cardiac wall patch can be calculated using the following growth relationships: 1. transverse_jones : Transversely isotropic growth driven by changes in fiber (fiber/cross-fiber growth) and radial (radial growth) stretch based on Jones & Oomen [1]. 2. transverse_witzenburg : Transversely isotropic growth driven by changes in fiber (fiber/cross-fiber growth) and radial (radial growth) stretch based on Witzenburg & Holmes [2]. 3. isotropic_oomen : Isotropic growth driven by changes in fiber stretch based on Oomen et al. [3]. 4. isotropic_jones : Isotropic growth driven by changes in fiber stretch based on Jones & Oomen [1]. 5. transverse_hybrid : Combination of the transverse_jones and transverse_witzenburg growth models. If you desire a different growth model, you can conveniently add your own growth model(s) in the growth.py file. Drivers of growth The changes in mechanics that drive growth can be induced by a variety of pathologies or clinical interventions. The boundary conditions needed to simulate these can be specified in the growth section of the input file. The following drivers are implemented: 1. Systemic arterial resistance ( growth.ras ): to simulate changes in afterload e.g. due to aortic stenosis. 2. Mitral valve regurgitation ( growth.rmvb ): to simulate changes in preload due to mitral valve regurgitation. 3. Abnormal heart rate ( growth.hr ): to simulate changes in heart rate. 4. Blood volume ( growth.sbv ): to simulate changes in blood volume and/or vasoconstriction. 5. Myocardial ischemia ( growth.ischemic ): to simulate changes in contractility due to acute ischemia (no stiffening during chronic ischemia is implemented as of yet). 6. Dyssynchrony ( growth.t_act ): to simulate changes in activation timing such as in left bundle branch block and cardiac resynchronization therapy. All these parameters will override the values specified in the other parameter sections ( heart , circulation , resistances ). The first 4 parameters need to be specified for each time point in the growth simulation, whereas changes in ischemia and dyssynchrony can be triggered at specific time points and need to be defined for each cardiac wall patch. # Jupyter magic %load_ext autoreload %autoreload 2 Example: mitral valve regurgitation We will here simulate transversely isotropic growth in a canine model with mitral valve regurgitation based on Jones & Oomen [1]. Just as in the single beat simulations, we need to specify the input file which contains the baseline model characteristics as well the growth boundary conditions. We use the growth.rmvb parameter to simulate mitral valve regurgitation and the growth model transverse_jones to simulate transversely isotropic growth. The model parameters are set to reflect a typical mitral regurgitation case in canines, see [1] for a more rigorous parameter calibration. Just like in the single beat simulations, we first need to (1) initialize the model, (2) simulate growth, and (3) visualize the results. Start with model intitialization and print the baseline and acute mitral valve regurgitation parameters: from monarch import Hatch import pathlib # Initialize model input_dir = pathlib.Path.cwd() / \"input_files\" input_canine = input_dir / \"canine_vo\" beats = Hatch(input_canine) print(\"Growth type: \" + beats.growth.type) print(\"Baseline R_mvb: \" + str(beats.growth.rmvb[0])) print(\"Acute R_mvb: \" + str(beats.growth.rmvb[1])) Growth type: transverse_jones Baseline R_mvb: 10000000000.0 Acute R_mvb: 0.3 A lower resistance means there is more regurgitation, with the intitial value set sufficiently high to ensure no regurgitation. We can now simulate growth , note that just like in the single beat simulations, the first simulation you run may take a while as the model is compiled. Subsequent simulations will be faster, rerun the cell to see this for yourself. # Simulate growth beats.let_it_grow() All model readouts are included in a Pandas format table beat.growth.outputs , similar to the single beat beat.outputs table but now every row includes a growth time point, with the index indicating which time point (in days). beats.growth.outputs .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } For easier analysis, any of the growth outputs can be plotted over time using the plot_growth function. The function takes a list of outputs (and optional units for plotting purposes) to plot. Here we plot the left ventricular end-diastolic volume (LVEDV) and end-systolic volume (LVESV): import monarch.metamophoses as meta meta.plot_growth(beats, [\"LVEDV\", \"LVESV\"], units=[\"mL\", \"mL\"]) One can also plot the pressure-volume loops of a single compartment over time. Here we plot the pressure-volume loop of the left ventricle at all time points (default); and the first, second, and last time point (specified through index argument): meta.pv_loop_growth(beats) meta.pv_loop_growth(beats, index=(0, 1, -1)) So why did the LV grow? Remember that we are using stretch-driven growth relationships, so let's visualize the changes in maximum fiber stretch and stress in all three walls: meta.plot_growth(beats, [\"MaxStretchLfw\", \"MaxStretchSw\", \"MaxStretchRfw\", \"MaxStressLfw\", \"MaxStressSw\", \"MaxStressRfw\"], units=[\"-\", \"-\", \"-\"]) From these figures, we anticipate that the left free wall (LFW) and septal wall (SW) will dilate due to the increase in maximum fiber stretch, and initially thin because of a decrease in maximum fiber stress. The right free wall (RFW) experience only very small changes in maximum fiber stretch and stress, and thus should not grow. We can test our hypothesis by looking at the growth tensor F_g , which can be visualized using the plot_fg function. Indeed, note how there is only noticeable growth in the left free wall (LFW) and septal wall (SW) as mitral regurgitation only effects the mechanics in the left ventricle. As expected from experimental and clinical studies, we observe dilation (increase in fiber (11) and cross-fiber (22) components of the growth tensor) and wall thinning (decrease in the radial (33) component of the growth tensor) in the LFW and SW. Initially, the change in wall volume due to growth ( J_g ) decreases due to faster thinning than dilation, but eventually the wall volume increases due to dilation exceeding wall thinning. meta.plot_fg(beats) Isotropic growth Let's now simulate isotropic growth in a canine model with mitral valve regurgitation. We will use the isotropic_jones growth model to simulate isotropic growth. # Initialize model and change growth type beats = Hatch(input_canine) beats.growth.type = \"isotropic_jones\" # Simulate growth beats.let_it_grow() Use the standard plotting functions to visualize the results, note now how there is a smaller increase in LVEDV and even a decrease in LVESV compared to the transversely isotropic growth model. meta.plot_growth(beats, [\"LVEDV\", \"LVESV\"], units=[\"mL\", \"mL\"]) meta.pv_loop_growth(beats) This is due to the isotropic growth model not allowing for wall thinning: meta.plot_fg(beats) References [1] Jones, C. E. & Oomen, P. J. A. Synergistic Biophysics and Machine Learning Modeling to Rapidly Predict Cardiac Growth Probability. bioRxiv 2024.07.17.603959 (2024) doi:10.1101/2024.07.17.603959. [2] Oomen, P. J. A., Phung, T.-K. N., Weinberg, S. H., Bilchick, K. C. & Holmes, J. W. A rapid electromechanical model to predict reverse remodeling following cardiac resynchronization therapy. Biomech Model Mechan 21, 231\u2013247 (2022). [3] Witzenburg, C. M. & Holmes, J. W. Predicting the Time Course of Ventricular Dilation and Thickening Using a Rapid Compartmental Model. J Cardiovasc Transl 11, 109\u2013122 (2018). [4] G\u00f6ktepe, S., Abilez, O. J., Parker, K. K. & Kuhl, E. A multiscale model for eccentric and concentric cardiac growth through sarcomerogenesis. J Theor Biol 265, 433\u2013442 (2010). [5] Rodriguez, E. K., Hoger, A. & McCulloch, A. D. Stress-dependent finite growth in soft elastic tissues. J Biomech 27, 455\u2013467 (1994).","title":"Growth"},{"location":"growth/#simulating-growth","text":"The true strength of this package is in its ability to simulate cardiac growth. This notebook will guide you through the process of simulating cardiac growth using a canine model with mitral valve regurgitation as an example. We recommend to first familiarize yourself with the single beat simulations in the single_beat.ipynb notebook before proceeding.","title":"Simulating growth"},{"location":"growth/#background","text":"","title":"Background"},{"location":"growth/#mechanics-based-growth-models","text":"We included several mechanics-based growth relationships based on reference [1-4]. The choice of growth model is up to the user and can be specified in the input file in growth.type . We use the kinematic growth model framework from Rodriguez et al. [5]. In brief, the way that all these models work is that they compare the current state of mechanics (typically elastic stretch) in each cardiac wall patch to that of a previous state. The growth model then calculates the amount of growth based on the difference between these states. The growth tensor F_g for each cardiac wall patch can be calculated using the following growth relationships: 1. transverse_jones : Transversely isotropic growth driven by changes in fiber (fiber/cross-fiber growth) and radial (radial growth) stretch based on Jones & Oomen [1]. 2. transverse_witzenburg : Transversely isotropic growth driven by changes in fiber (fiber/cross-fiber growth) and radial (radial growth) stretch based on Witzenburg & Holmes [2]. 3. isotropic_oomen : Isotropic growth driven by changes in fiber stretch based on Oomen et al. [3]. 4. isotropic_jones : Isotropic growth driven by changes in fiber stretch based on Jones & Oomen [1]. 5. transverse_hybrid : Combination of the transverse_jones and transverse_witzenburg growth models. If you desire a different growth model, you can conveniently add your own growth model(s) in the growth.py file.","title":"Mechanics-based growth models"},{"location":"growth/#drivers-of-growth","text":"The changes in mechanics that drive growth can be induced by a variety of pathologies or clinical interventions. The boundary conditions needed to simulate these can be specified in the growth section of the input file. The following drivers are implemented: 1. Systemic arterial resistance ( growth.ras ): to simulate changes in afterload e.g. due to aortic stenosis. 2. Mitral valve regurgitation ( growth.rmvb ): to simulate changes in preload due to mitral valve regurgitation. 3. Abnormal heart rate ( growth.hr ): to simulate changes in heart rate. 4. Blood volume ( growth.sbv ): to simulate changes in blood volume and/or vasoconstriction. 5. Myocardial ischemia ( growth.ischemic ): to simulate changes in contractility due to acute ischemia (no stiffening during chronic ischemia is implemented as of yet). 6. Dyssynchrony ( growth.t_act ): to simulate changes in activation timing such as in left bundle branch block and cardiac resynchronization therapy. All these parameters will override the values specified in the other parameter sections ( heart , circulation , resistances ). The first 4 parameters need to be specified for each time point in the growth simulation, whereas changes in ischemia and dyssynchrony can be triggered at specific time points and need to be defined for each cardiac wall patch. # Jupyter magic %load_ext autoreload %autoreload 2","title":"Drivers of growth"},{"location":"growth/#example-mitral-valve-regurgitation","text":"We will here simulate transversely isotropic growth in a canine model with mitral valve regurgitation based on Jones & Oomen [1]. Just as in the single beat simulations, we need to specify the input file which contains the baseline model characteristics as well the growth boundary conditions. We use the growth.rmvb parameter to simulate mitral valve regurgitation and the growth model transverse_jones to simulate transversely isotropic growth. The model parameters are set to reflect a typical mitral regurgitation case in canines, see [1] for a more rigorous parameter calibration. Just like in the single beat simulations, we first need to (1) initialize the model, (2) simulate growth, and (3) visualize the results. Start with model intitialization and print the baseline and acute mitral valve regurgitation parameters: from monarch import Hatch import pathlib # Initialize model input_dir = pathlib.Path.cwd() / \"input_files\" input_canine = input_dir / \"canine_vo\" beats = Hatch(input_canine) print(\"Growth type: \" + beats.growth.type) print(\"Baseline R_mvb: \" + str(beats.growth.rmvb[0])) print(\"Acute R_mvb: \" + str(beats.growth.rmvb[1])) Growth type: transverse_jones Baseline R_mvb: 10000000000.0 Acute R_mvb: 0.3 A lower resistance means there is more regurgitation, with the intitial value set sufficiently high to ensure no regurgitation. We can now simulate growth , note that just like in the single beat simulations, the first simulation you run may take a while as the model is compiled. Subsequent simulations will be faster, rerun the cell to see this for yourself. # Simulate growth beats.let_it_grow() All model readouts are included in a Pandas format table beat.growth.outputs , similar to the single beat beat.outputs table but now every row includes a growth time point, with the index indicating which time point (in days). beats.growth.outputs .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } For easier analysis, any of the growth outputs can be plotted over time using the plot_growth function. The function takes a list of outputs (and optional units for plotting purposes) to plot. Here we plot the left ventricular end-diastolic volume (LVEDV) and end-systolic volume (LVESV): import monarch.metamophoses as meta meta.plot_growth(beats, [\"LVEDV\", \"LVESV\"], units=[\"mL\", \"mL\"]) One can also plot the pressure-volume loops of a single compartment over time. Here we plot the pressure-volume loop of the left ventricle at all time points (default); and the first, second, and last time point (specified through index argument): meta.pv_loop_growth(beats) meta.pv_loop_growth(beats, index=(0, 1, -1)) So why did the LV grow? Remember that we are using stretch-driven growth relationships, so let's visualize the changes in maximum fiber stretch and stress in all three walls: meta.plot_growth(beats, [\"MaxStretchLfw\", \"MaxStretchSw\", \"MaxStretchRfw\", \"MaxStressLfw\", \"MaxStressSw\", \"MaxStressRfw\"], units=[\"-\", \"-\", \"-\"]) From these figures, we anticipate that the left free wall (LFW) and septal wall (SW) will dilate due to the increase in maximum fiber stretch, and initially thin because of a decrease in maximum fiber stress. The right free wall (RFW) experience only very small changes in maximum fiber stretch and stress, and thus should not grow. We can test our hypothesis by looking at the growth tensor F_g , which can be visualized using the plot_fg function. Indeed, note how there is only noticeable growth in the left free wall (LFW) and septal wall (SW) as mitral regurgitation only effects the mechanics in the left ventricle. As expected from experimental and clinical studies, we observe dilation (increase in fiber (11) and cross-fiber (22) components of the growth tensor) and wall thinning (decrease in the radial (33) component of the growth tensor) in the LFW and SW. Initially, the change in wall volume due to growth ( J_g ) decreases due to faster thinning than dilation, but eventually the wall volume increases due to dilation exceeding wall thinning. meta.plot_fg(beats)","title":"Example: mitral valve regurgitation"},{"location":"growth/#isotropic-growth","text":"Let's now simulate isotropic growth in a canine model with mitral valve regurgitation. We will use the isotropic_jones growth model to simulate isotropic growth. # Initialize model and change growth type beats = Hatch(input_canine) beats.growth.type = \"isotropic_jones\" # Simulate growth beats.let_it_grow() Use the standard plotting functions to visualize the results, note now how there is a smaller increase in LVEDV and even a decrease in LVESV compared to the transversely isotropic growth model. meta.plot_growth(beats, [\"LVEDV\", \"LVESV\"], units=[\"mL\", \"mL\"]) meta.pv_loop_growth(beats) This is due to the isotropic growth model not allowing for wall thinning: meta.plot_fg(beats)","title":"Isotropic growth"},{"location":"growth/#references","text":"[1] Jones, C. E. & Oomen, P. J. A. Synergistic Biophysics and Machine Learning Modeling to Rapidly Predict Cardiac Growth Probability. bioRxiv 2024.07.17.603959 (2024) doi:10.1101/2024.07.17.603959. [2] Oomen, P. J. A., Phung, T.-K. N., Weinberg, S. H., Bilchick, K. C. & Holmes, J. W. A rapid electromechanical model to predict reverse remodeling following cardiac resynchronization therapy. Biomech Model Mechan 21, 231\u2013247 (2022). [3] Witzenburg, C. M. & Holmes, J. W. Predicting the Time Course of Ventricular Dilation and Thickening Using a Rapid Compartmental Model. J Cardiovasc Transl 11, 109\u2013122 (2018). [4] G\u00f6ktepe, S., Abilez, O. J., Parker, K. K. & Kuhl, E. A multiscale model for eccentric and concentric cardiac growth through sarcomerogenesis. J Theor Biol 265, 433\u2013442 (2010). [5] Rodriguez, E. K., Hoger, A. & McCulloch, A. D. Stress-dependent finite growth in soft elastic tissues. J Biomech 27, 455\u2013467 (1994).","title":"References"},{"location":"single_beats/","text":"Getting started with monarch This notebook demonstrates how the monarch package can be used to simulate cardiac physiology and mechanics. We will demonstrate how the model can be run and results be visualized and analyzed, and share some example cases. This notebook focuses on single-beat analyses only, growth simulations are covered in the growth notebook. # Jupyter magic %load_ext autoreload %autoreload 2 Basic usage Running a single cardiac cycle We first need to initialize the model and import it into this notebook. We will use an input file containing input parameters that simulate a representative human case. By initializing the model, the parameters from the JSON-format input file are being imported, and some initial arrays are pre-allocated, such as time, and compartmental pressures and volumes. You can create your own input file using the included examples. from monarch import Hatch import pathlib # Initialize model input_dir = pathlib.Path.cwd() / \"input_files\" input_human = input_dir / 'human' beat = Hatch(input_human) To simulate a single cardiac cycle, we call on the core function of the model: just_beat_it . This will simulate a cardiac cycle using the built-in 4th-order Rung-Kutta solver using the initial conditions provided in the input file parameter k . After running one cardiac cycle, the solver checks if a steady-state circulation has been reached by comparing the differences between the initial and final blood volumes in all compartments. If these differences are below a certain threshold (default 1e-6), the model is considered to have converged. If the model has not converged, the solver will run another cardiac cycle with the final volumes set as the new initial conditions. The solver will continue to run cardiac cycles until the model has converged. The solver will also stop if the maximum number of iterations is reached (input file parameter iter_max ). The solver will print the volume error in each compartment if the print_solve parameter is set to True (default False ). The first time this code is executed, the function is much slower, because the python code has to be compiled first into machine code using Numba. All the following times the function is called, the compiled code is used, and the function is much faster. # Run model and display convergence beat.just_beat_it(print_solve=True) Iteration 0: 2.59e-01 2.61e-01 1.06e-01 8.88e-02 7.64e-02 2.59e-01 2.69e-01 1.44e-01 Iteration 1: 9.75e-02 1.11e-02 2.67e-02 1.32e-02 1.10e-02 5.83e-04 9.91e-03 2.36e-02 Iteration 2: 6.42e-02 7.47e-03 1.96e-02 1.48e-02 7.42e-03 7.85e-04 1.32e-02 1.31e-02 Iteration 3: 4.20e-02 4.97e-03 1.37e-02 1.25e-02 5.06e-03 5.09e-04 9.16e-03 8.08e-03 Iteration 4: 2.73e-02 3.26e-03 9.36e-03 9.34e-03 3.30e-03 3.18e-04 6.18e-03 5.18e-03 Iteration 5: 1.77e-02 2.13e-03 6.27e-03 6.62e-03 2.06e-03 1.94e-04 4.10e-03 3.41e-03 Iteration 6: 1.14e-02 1.37e-03 4.12e-03 4.54e-03 1.23e-03 1.15e-04 2.68e-03 2.29e-03 Iteration 7: 7.23e-03 8.79e-04 2.67e-03 3.05e-03 7.00e-04 6.48e-05 1.73e-03 1.56e-03 Steady-state circulation established Visualizing the results The module metamorphoses includes a series of convenient plotting functions on the Monarch class. For example, we can plot the pressure-volume loops of the left and right ventricles: # Import plotting functions import monarch.metamophoses as meta # Plot LV pressure-volume loop meta.pv_loop(beat, compartments=(\"LV\", \"RV\")) Note that figures can be exported by specifying a file_path parameter ( filename has a default but can user-specified too), as well as export format file_format (default .pdf ). Figure display can be disabled by setting show_fig=False . The following cell will only export the figure in the same directory as this notebook and not display it: meta.pv_loop(beat, compartments=(\"LV\", \"RV\"), show_fig=False, file_path='./') We can also plot the Wiggers diagram, which is useful to analyze LV behaviour: meta.wiggers_diagram(beat) meta.cardiac_geometry(beat, real_wall_thickness=True) there is also a function to plot all pressures and volumes, which is useful to compare the different compartments and for code debugging and development: meta.pressures_volumes(beat) Another useful tool is that a range of typical physiological readouts are calculated and stored in a Pandas table format: from IPython.display import display display(beat.outputs) Import and export The Monarch class can import and export the results of a simulation. The key results are stored in .hdf5 format to maximize compatibility with all software versions and operating systems. We here store the results of the current simulation in the same directory as this notebook: import pathlib # Get current directory cdir = pathlib.Path.cwd() # Export results beat.export_beat_sim(cdir, \"demo\") The results can be imported again into an existing or new Monarch class. Here we demonstrate how to export the results and show that the results of the new class are the same as the original class: # Start new class and load previous results beat_load = Hatch(input_human) beat_load.import_beat_sim(cdir, \"demo\") display(beat.outputs) display(beat_load.outputs) Additionally, the converged model states are by default stored in a JSON file in the source code directory, which can be imported when rerunning a new simulation. This is useful for example when you want to run a series of simulations with similar parameters, thus reducing the amount of iterations required to reach convergence and reducing computation time. However, when running a model with substantially different parameters it can lead to convergence issues, that is why it is by default disabled\u2013also, the model is so fast that the difference is typically negligible. You can also delete the converged solution JSON file to ensure the model starts from a clean slate when using converged solution imports. We here show the different amount of solver iterations needed to reach convergence with and without using the converged solution: print(\"Run 1: standard, do not use converged solution\") beat = Hatch(input_human) beat.just_beat_it(print_solve=True) print(\"\\nRun 2: use converged solution\") beat = Hatch(input_human) beat.just_beat_it(print_solve=True, use_converged=True) print(\"\\nRun 3: clear converged solution\") beat = Hatch(input_human) beat.clear_converged_sol() beat.just_beat_it(print_solve=True, use_converged=True) Run 1: standard, do not use converged solution Iteration 0: 2.59e-01 2.61e-01 1.06e-01 8.88e-02 7.64e-02 2.59e-01 2.69e-01 1.44e-01 Iteration 1: 9.75e-02 1.11e-02 2.67e-02 1.32e-02 1.10e-02 5.83e-04 9.91e-03 2.36e-02 Iteration 2: 6.42e-02 7.47e-03 1.96e-02 1.48e-02 7.42e-03 7.85e-04 1.32e-02 1.31e-02 Iteration 3: 4.20e-02 4.97e-03 1.37e-02 1.25e-02 5.06e-03 5.09e-04 9.16e-03 8.08e-03 Iteration 4: 2.73e-02 3.26e-03 9.36e-03 9.34e-03 3.30e-03 3.18e-04 6.18e-03 5.18e-03 Iteration 5: 1.77e-02 2.13e-03 6.27e-03 6.62e-03 2.06e-03 1.94e-04 4.10e-03 3.41e-03 Iteration 6: 1.14e-02 1.37e-03 4.12e-03 4.54e-03 1.23e-03 1.15e-04 2.68e-03 2.29e-03 Iteration 7: 7.23e-03 8.79e-04 2.67e-03 3.05e-03 7.00e-04 6.48e-05 1.73e-03 1.56e-03 Steady-state circulation established Run 2: use converged solution Iteration 0: 7.23e-03 8.79e-04 2.68e-03 3.04e-03 7.01e-04 6.49e-05 1.73e-03 1.56e-03 Steady-state circulation established Run 3: clear converged solution Iteration 0: 2.59e-01 2.61e-01 1.06e-01 8.88e-02 7.64e-02 2.59e-01 2.69e-01 1.44e-01 Iteration 1: 9.75e-02 1.11e-02 2.67e-02 1.32e-02 1.10e-02 5.83e-04 9.91e-03 2.36e-02 Iteration 2: 6.42e-02 7.47e-03 1.96e-02 1.48e-02 7.42e-03 7.85e-04 1.32e-02 1.31e-02 Iteration 3: 4.20e-02 4.97e-03 1.37e-02 1.25e-02 5.06e-03 5.09e-04 9.16e-03 8.08e-03 Iteration 4: 2.73e-02 3.26e-03 9.36e-03 9.34e-03 3.30e-03 3.18e-04 6.18e-03 5.18e-03 Iteration 5: 1.77e-02 2.13e-03 6.27e-03 6.62e-03 2.06e-03 1.94e-04 4.10e-03 3.41e-03 Iteration 6: 1.14e-02 1.37e-03 4.12e-03 4.54e-03 1.23e-03 1.15e-04 2.68e-03 2.29e-03 Iteration 7: 7.23e-03 8.79e-04 2.67e-03 3.05e-03 7.00e-04 6.48e-05 1.73e-03 1.56e-03 Steady-state circulation established Examples Now that we can run and plot a single cardiac cycle, we can test what happens to the model outcomes if change certain model parameters. Example 1: Heart rate Let's first run two cardiac cycles with different heart rates: 60 and 90 bpm. We can use the built-in method change_pars to conveniently change any parameter, here we change the heart rate parameter. We will run multiple heart beats and plot the pressure-volume loops of the left ventricle to observe the effect of heart rate on stroke volume and cardiac output: import numpy as np # Preallocate beats and choose heart rates beats = [] heart_rates = np.arange(50, 101, 5) # Simulate each heart rate for hr in heart_rates: # Initialize and set HR beat = Hatch(input_human) beat.change_pars({\"HR\": hr}) # Run model and store results beat.just_beat_it() beats.append(beat) # Plot multiple PV loops of a single compartment, default LV meta.pv_loops(beats, model_names=heart_rates, var_name=\"HR\", y_lim=(0, 150), x_lim=(50, 150)) Note that the stroke volume decreases with increasing heart rate. This is due to the Frank-Starling law: the shorter filling time decreases end-diastolic volume which in turn decreases contractility. However, the increasing heart rate does lead to an increase in stroke volume. Let's use the output tables to proof that our model obeys the Frank-Starling law: import matplotlib.pyplot as plt # Extract outputs of all simulations sv, co, hr, lvedv = [], [], [], [] for beat in beats: hr.append(beat.outputs[\"HR\"]) sv.append(beat.outputs[\"LVSV\"]) co.append(beat.outputs[\"LVCO\"]) lvedv.append(beat.outputs[\"LVEDV\"]) # Plot results fig, ax = plt.subplots(2, 2) ax[0, 0].plot(hr, sv) ax[1, 0].plot(hr, co) ax[0, 1].plot(lvedv, sv) ax[1, 1].plot(lvedv, co) ax[1, 0].set_xlabel(\"HR (bpm)\") ax[1, 1].set_xlabel(\"LVEDV (mmHg)\") ax[0, 0].set_ylabel(\"SV (mL)\") ax[1, 0].set_ylabel(\"CO (mL/min)\") plt.show() Example 2: Myocardial ischemia Myocardial ischemia, commonly known as a heart attack, occurs when blood flow to the heart muscle is reduced or blocked, preventing the heart muscle from receiving enough oxygen. This can lead to cell death and scar tissue formation. We can simulate the initial ischemia by setting the contractility of a region to zero. We will simulate a healthy baseline and an ischemic septal case: # Initialize and run healthy baseline model beat_baseline = Hatch(input_human) beat_baseline.just_beat_it() # Set septal wall to be ischemic and rerun simulation beat_ischemic = Hatch(input_human) beat_ischemic.heart.sf_act[2] = 0.0 beat_ischemic.just_beat_it() We then plot the pressure-volume loops to observe the effect of ischemia on the heart's function, notice how the stroke volume decreases, end-diastolic pressure increases, and end-systolic pressure decrease in the ischemic case. Note that this is without any hemodynamic reflexes, that is the body compensating for the reduction in stroke volume by increasing heart rate, contractility, and/or preload. meta.pv_loops([beat_baseline, beat_ischemic], model_names=[\"Healthy\", \"Ischemic\"]) We can also plot stretch to reveal the typical behavior of a myocardial ischemic region: the now-ischemic septal wall (SW) experiences pre-load during early contraction of the left and right free walls (LFW and RFW), and does not contract at all. Note that in this simulation resembles acute ischemia: there is no remodeling, typically this could comprise of scar formation and subsequent wall thinning in the ischemic region, and hypertrophy of the healthy, remote regions. The latter can be simulated using our growth functions. meta.stretch(beat_baseline, fig_size=(4, 3)) meta.stretch(beat_ischemic, fig_size=(4, 3), legend=False) Example 3: Activation timing This model was specifically designed to simulate dyssynchronous heart failure. The ventricular composite geometry consists of three spherical walls based on the TriSeg method [3], and each wall can be split into a series of individual segments, or patches [3]. Each patch can be assigned a different activation timing through the * heart.t_act * parameter, where each value stands for a patch, and the wall each patch is located in is specified in heart.patches , where left free wall is 0, right wall is 1, septal wall is 2, left atrium is 3, and right atrium is 4. Not that the other cardiac parameters need to be set for each patch as well, which comes with pros and cons: each patch can be assigned different properties, but now each parameter requires a list of specified values equal to the number of patches. The input file input_oomen2022 has patches are set up according to the 16-segment AHA model, with 5 patches in the septal wall and 11 in the left free wall. Additionally, the right free wall is split up into 5 patches, while the atria are single-patch spheres. This input file is based on [1], note however the code version used for that paper included several differences, most notably no atria, so the results will be slightly different. Moreover, the results for that paper were generated using the original MATLAB version of this code, which is still publicly available on GitHub. The single-beat cases simulated here also do not include hemodynamic compensation through blood volume and arterial resistance, but they are included in the growth simulations using this same input file. Start with a healthy baseline heart beat: input_canine = input_dir / 'oomen2022' beat_baseline = Hatch(input_canine) beat_baseline.just_beat_it() Using this input file, we can simulate a left bundle branch block (LBBB) and cardiac resynchronization therapy (CRT) case. We will set the activation timing using the activation times stored in the growth part of the input, see the growth notebook for more information. beat_lbbb = Hatch(input_canine) beat_lbbb.change_pars({\"tact\": beat_lbbb.growth.t_act[1, :]}) beat_lbbb.just_beat_it() beat_crt = Hatch(input_canine) beat_crt.change_pars({\"tact\": beat_crt.growth.t_act[-1, :]}) beat_crt.just_beat_it() We will then plot the pressure-volume loops and stretch to observe the effect of activation timing on cardiac function, with LBBB causing a decrease in stroke volume and CRT an almost complete recovery of stroke volume: meta.pv_loops([beat_baseline, beat_lbbb, beat_crt], model_names=[\"Baseline\", \"LBBB\", \"CRT\"]) Plotting the stretch reveals the typical behavior of LBBB and CRT: LBBB causes a delay in activation, increased preload, and increased work of the left free wall, while the septal contracts less and rebound stretch is noticable in several patches, however less than seen in a typical ultrasound or MRI. CRT mostly recovers these effects towards baseline: meta.stretch(beat_baseline, fig_size=(4, 3), y_lim=(0.8, 1.2)) meta.stretch(beat_lbbb, fig_size=(4, 3), legend=False, y_lim=(0.8, 1.2)) meta.stretch(beat_crt, fig_size=(4, 3), legend=False, y_lim=(0.8, 1.2)) References [1] Oomen, P. J. A., Phung, T.-K. N., Weinberg, S. H., Bilchick, K. C. & Holmes, J. W. A rapid electromechanical model to predict reverse remodeling following cardiac resynchronization therapy. Biomech Model Mechan 21, 231\u2013247 (2022). [2] Lumens, J., Delhaas, T., Kirn, B. & Arts, T. Three-Wall Segment (TriSeg) Model Describing Mechanics and Hemodynamics of Ventricular Interaction. Ann Biomed Eng 37, 2234\u20132255 (2009). [3] Walmsley, J. et al. Fast Simulation of Mechanical Heterogeneity in the Electrically Asynchronous Heart Using the MultiPatch Module. Plos Comput Biol 11, e1004284 (2015).","title":"Single Heartbeat Demonstration"},{"location":"single_beats/#getting-started-with-monarch","text":"This notebook demonstrates how the monarch package can be used to simulate cardiac physiology and mechanics. We will demonstrate how the model can be run and results be visualized and analyzed, and share some example cases. This notebook focuses on single-beat analyses only, growth simulations are covered in the growth notebook. # Jupyter magic %load_ext autoreload %autoreload 2","title":"Getting started with monarch"},{"location":"single_beats/#basic-usage","text":"","title":"Basic usage"},{"location":"single_beats/#running-a-single-cardiac-cycle","text":"We first need to initialize the model and import it into this notebook. We will use an input file containing input parameters that simulate a representative human case. By initializing the model, the parameters from the JSON-format input file are being imported, and some initial arrays are pre-allocated, such as time, and compartmental pressures and volumes. You can create your own input file using the included examples. from monarch import Hatch import pathlib # Initialize model input_dir = pathlib.Path.cwd() / \"input_files\" input_human = input_dir / 'human' beat = Hatch(input_human) To simulate a single cardiac cycle, we call on the core function of the model: just_beat_it . This will simulate a cardiac cycle using the built-in 4th-order Rung-Kutta solver using the initial conditions provided in the input file parameter k . After running one cardiac cycle, the solver checks if a steady-state circulation has been reached by comparing the differences between the initial and final blood volumes in all compartments. If these differences are below a certain threshold (default 1e-6), the model is considered to have converged. If the model has not converged, the solver will run another cardiac cycle with the final volumes set as the new initial conditions. The solver will continue to run cardiac cycles until the model has converged. The solver will also stop if the maximum number of iterations is reached (input file parameter iter_max ). The solver will print the volume error in each compartment if the print_solve parameter is set to True (default False ). The first time this code is executed, the function is much slower, because the python code has to be compiled first into machine code using Numba. All the following times the function is called, the compiled code is used, and the function is much faster. # Run model and display convergence beat.just_beat_it(print_solve=True) Iteration 0: 2.59e-01 2.61e-01 1.06e-01 8.88e-02 7.64e-02 2.59e-01 2.69e-01 1.44e-01 Iteration 1: 9.75e-02 1.11e-02 2.67e-02 1.32e-02 1.10e-02 5.83e-04 9.91e-03 2.36e-02 Iteration 2: 6.42e-02 7.47e-03 1.96e-02 1.48e-02 7.42e-03 7.85e-04 1.32e-02 1.31e-02 Iteration 3: 4.20e-02 4.97e-03 1.37e-02 1.25e-02 5.06e-03 5.09e-04 9.16e-03 8.08e-03 Iteration 4: 2.73e-02 3.26e-03 9.36e-03 9.34e-03 3.30e-03 3.18e-04 6.18e-03 5.18e-03 Iteration 5: 1.77e-02 2.13e-03 6.27e-03 6.62e-03 2.06e-03 1.94e-04 4.10e-03 3.41e-03 Iteration 6: 1.14e-02 1.37e-03 4.12e-03 4.54e-03 1.23e-03 1.15e-04 2.68e-03 2.29e-03 Iteration 7: 7.23e-03 8.79e-04 2.67e-03 3.05e-03 7.00e-04 6.48e-05 1.73e-03 1.56e-03 Steady-state circulation established","title":"Running a single cardiac cycle"},{"location":"single_beats/#visualizing-the-results","text":"The module metamorphoses includes a series of convenient plotting functions on the Monarch class. For example, we can plot the pressure-volume loops of the left and right ventricles: # Import plotting functions import monarch.metamophoses as meta # Plot LV pressure-volume loop meta.pv_loop(beat, compartments=(\"LV\", \"RV\")) Note that figures can be exported by specifying a file_path parameter ( filename has a default but can user-specified too), as well as export format file_format (default .pdf ). Figure display can be disabled by setting show_fig=False . The following cell will only export the figure in the same directory as this notebook and not display it: meta.pv_loop(beat, compartments=(\"LV\", \"RV\"), show_fig=False, file_path='./') We can also plot the Wiggers diagram, which is useful to analyze LV behaviour: meta.wiggers_diagram(beat) meta.cardiac_geometry(beat, real_wall_thickness=True) there is also a function to plot all pressures and volumes, which is useful to compare the different compartments and for code debugging and development: meta.pressures_volumes(beat) Another useful tool is that a range of typical physiological readouts are calculated and stored in a Pandas table format: from IPython.display import display display(beat.outputs)","title":"Visualizing the results"},{"location":"single_beats/#import-and-export","text":"The Monarch class can import and export the results of a simulation. The key results are stored in .hdf5 format to maximize compatibility with all software versions and operating systems. We here store the results of the current simulation in the same directory as this notebook: import pathlib # Get current directory cdir = pathlib.Path.cwd() # Export results beat.export_beat_sim(cdir, \"demo\") The results can be imported again into an existing or new Monarch class. Here we demonstrate how to export the results and show that the results of the new class are the same as the original class: # Start new class and load previous results beat_load = Hatch(input_human) beat_load.import_beat_sim(cdir, \"demo\") display(beat.outputs) display(beat_load.outputs) Additionally, the converged model states are by default stored in a JSON file in the source code directory, which can be imported when rerunning a new simulation. This is useful for example when you want to run a series of simulations with similar parameters, thus reducing the amount of iterations required to reach convergence and reducing computation time. However, when running a model with substantially different parameters it can lead to convergence issues, that is why it is by default disabled\u2013also, the model is so fast that the difference is typically negligible. You can also delete the converged solution JSON file to ensure the model starts from a clean slate when using converged solution imports. We here show the different amount of solver iterations needed to reach convergence with and without using the converged solution: print(\"Run 1: standard, do not use converged solution\") beat = Hatch(input_human) beat.just_beat_it(print_solve=True) print(\"\\nRun 2: use converged solution\") beat = Hatch(input_human) beat.just_beat_it(print_solve=True, use_converged=True) print(\"\\nRun 3: clear converged solution\") beat = Hatch(input_human) beat.clear_converged_sol() beat.just_beat_it(print_solve=True, use_converged=True) Run 1: standard, do not use converged solution Iteration 0: 2.59e-01 2.61e-01 1.06e-01 8.88e-02 7.64e-02 2.59e-01 2.69e-01 1.44e-01 Iteration 1: 9.75e-02 1.11e-02 2.67e-02 1.32e-02 1.10e-02 5.83e-04 9.91e-03 2.36e-02 Iteration 2: 6.42e-02 7.47e-03 1.96e-02 1.48e-02 7.42e-03 7.85e-04 1.32e-02 1.31e-02 Iteration 3: 4.20e-02 4.97e-03 1.37e-02 1.25e-02 5.06e-03 5.09e-04 9.16e-03 8.08e-03 Iteration 4: 2.73e-02 3.26e-03 9.36e-03 9.34e-03 3.30e-03 3.18e-04 6.18e-03 5.18e-03 Iteration 5: 1.77e-02 2.13e-03 6.27e-03 6.62e-03 2.06e-03 1.94e-04 4.10e-03 3.41e-03 Iteration 6: 1.14e-02 1.37e-03 4.12e-03 4.54e-03 1.23e-03 1.15e-04 2.68e-03 2.29e-03 Iteration 7: 7.23e-03 8.79e-04 2.67e-03 3.05e-03 7.00e-04 6.48e-05 1.73e-03 1.56e-03 Steady-state circulation established Run 2: use converged solution Iteration 0: 7.23e-03 8.79e-04 2.68e-03 3.04e-03 7.01e-04 6.49e-05 1.73e-03 1.56e-03 Steady-state circulation established Run 3: clear converged solution Iteration 0: 2.59e-01 2.61e-01 1.06e-01 8.88e-02 7.64e-02 2.59e-01 2.69e-01 1.44e-01 Iteration 1: 9.75e-02 1.11e-02 2.67e-02 1.32e-02 1.10e-02 5.83e-04 9.91e-03 2.36e-02 Iteration 2: 6.42e-02 7.47e-03 1.96e-02 1.48e-02 7.42e-03 7.85e-04 1.32e-02 1.31e-02 Iteration 3: 4.20e-02 4.97e-03 1.37e-02 1.25e-02 5.06e-03 5.09e-04 9.16e-03 8.08e-03 Iteration 4: 2.73e-02 3.26e-03 9.36e-03 9.34e-03 3.30e-03 3.18e-04 6.18e-03 5.18e-03 Iteration 5: 1.77e-02 2.13e-03 6.27e-03 6.62e-03 2.06e-03 1.94e-04 4.10e-03 3.41e-03 Iteration 6: 1.14e-02 1.37e-03 4.12e-03 4.54e-03 1.23e-03 1.15e-04 2.68e-03 2.29e-03 Iteration 7: 7.23e-03 8.79e-04 2.67e-03 3.05e-03 7.00e-04 6.48e-05 1.73e-03 1.56e-03 Steady-state circulation established","title":"Import and export"},{"location":"single_beats/#examples","text":"Now that we can run and plot a single cardiac cycle, we can test what happens to the model outcomes if change certain model parameters.","title":"Examples"},{"location":"single_beats/#example-1-heart-rate","text":"Let's first run two cardiac cycles with different heart rates: 60 and 90 bpm. We can use the built-in method change_pars to conveniently change any parameter, here we change the heart rate parameter. We will run multiple heart beats and plot the pressure-volume loops of the left ventricle to observe the effect of heart rate on stroke volume and cardiac output: import numpy as np # Preallocate beats and choose heart rates beats = [] heart_rates = np.arange(50, 101, 5) # Simulate each heart rate for hr in heart_rates: # Initialize and set HR beat = Hatch(input_human) beat.change_pars({\"HR\": hr}) # Run model and store results beat.just_beat_it() beats.append(beat) # Plot multiple PV loops of a single compartment, default LV meta.pv_loops(beats, model_names=heart_rates, var_name=\"HR\", y_lim=(0, 150), x_lim=(50, 150)) Note that the stroke volume decreases with increasing heart rate. This is due to the Frank-Starling law: the shorter filling time decreases end-diastolic volume which in turn decreases contractility. However, the increasing heart rate does lead to an increase in stroke volume. Let's use the output tables to proof that our model obeys the Frank-Starling law: import matplotlib.pyplot as plt # Extract outputs of all simulations sv, co, hr, lvedv = [], [], [], [] for beat in beats: hr.append(beat.outputs[\"HR\"]) sv.append(beat.outputs[\"LVSV\"]) co.append(beat.outputs[\"LVCO\"]) lvedv.append(beat.outputs[\"LVEDV\"]) # Plot results fig, ax = plt.subplots(2, 2) ax[0, 0].plot(hr, sv) ax[1, 0].plot(hr, co) ax[0, 1].plot(lvedv, sv) ax[1, 1].plot(lvedv, co) ax[1, 0].set_xlabel(\"HR (bpm)\") ax[1, 1].set_xlabel(\"LVEDV (mmHg)\") ax[0, 0].set_ylabel(\"SV (mL)\") ax[1, 0].set_ylabel(\"CO (mL/min)\") plt.show()","title":"Example 1: Heart rate"},{"location":"single_beats/#example-2-myocardial-ischemia","text":"Myocardial ischemia, commonly known as a heart attack, occurs when blood flow to the heart muscle is reduced or blocked, preventing the heart muscle from receiving enough oxygen. This can lead to cell death and scar tissue formation. We can simulate the initial ischemia by setting the contractility of a region to zero. We will simulate a healthy baseline and an ischemic septal case: # Initialize and run healthy baseline model beat_baseline = Hatch(input_human) beat_baseline.just_beat_it() # Set septal wall to be ischemic and rerun simulation beat_ischemic = Hatch(input_human) beat_ischemic.heart.sf_act[2] = 0.0 beat_ischemic.just_beat_it() We then plot the pressure-volume loops to observe the effect of ischemia on the heart's function, notice how the stroke volume decreases, end-diastolic pressure increases, and end-systolic pressure decrease in the ischemic case. Note that this is without any hemodynamic reflexes, that is the body compensating for the reduction in stroke volume by increasing heart rate, contractility, and/or preload. meta.pv_loops([beat_baseline, beat_ischemic], model_names=[\"Healthy\", \"Ischemic\"]) We can also plot stretch to reveal the typical behavior of a myocardial ischemic region: the now-ischemic septal wall (SW) experiences pre-load during early contraction of the left and right free walls (LFW and RFW), and does not contract at all. Note that in this simulation resembles acute ischemia: there is no remodeling, typically this could comprise of scar formation and subsequent wall thinning in the ischemic region, and hypertrophy of the healthy, remote regions. The latter can be simulated using our growth functions. meta.stretch(beat_baseline, fig_size=(4, 3)) meta.stretch(beat_ischemic, fig_size=(4, 3), legend=False)","title":"Example 2: Myocardial ischemia"},{"location":"single_beats/#example-3-activation-timing","text":"This model was specifically designed to simulate dyssynchronous heart failure. The ventricular composite geometry consists of three spherical walls based on the TriSeg method [3], and each wall can be split into a series of individual segments, or patches [3]. Each patch can be assigned a different activation timing through the * heart.t_act * parameter, where each value stands for a patch, and the wall each patch is located in is specified in heart.patches , where left free wall is 0, right wall is 1, septal wall is 2, left atrium is 3, and right atrium is 4. Not that the other cardiac parameters need to be set for each patch as well, which comes with pros and cons: each patch can be assigned different properties, but now each parameter requires a list of specified values equal to the number of patches. The input file input_oomen2022 has patches are set up according to the 16-segment AHA model, with 5 patches in the septal wall and 11 in the left free wall. Additionally, the right free wall is split up into 5 patches, while the atria are single-patch spheres. This input file is based on [1], note however the code version used for that paper included several differences, most notably no atria, so the results will be slightly different. Moreover, the results for that paper were generated using the original MATLAB version of this code, which is still publicly available on GitHub. The single-beat cases simulated here also do not include hemodynamic compensation through blood volume and arterial resistance, but they are included in the growth simulations using this same input file. Start with a healthy baseline heart beat: input_canine = input_dir / 'oomen2022' beat_baseline = Hatch(input_canine) beat_baseline.just_beat_it() Using this input file, we can simulate a left bundle branch block (LBBB) and cardiac resynchronization therapy (CRT) case. We will set the activation timing using the activation times stored in the growth part of the input, see the growth notebook for more information. beat_lbbb = Hatch(input_canine) beat_lbbb.change_pars({\"tact\": beat_lbbb.growth.t_act[1, :]}) beat_lbbb.just_beat_it() beat_crt = Hatch(input_canine) beat_crt.change_pars({\"tact\": beat_crt.growth.t_act[-1, :]}) beat_crt.just_beat_it() We will then plot the pressure-volume loops and stretch to observe the effect of activation timing on cardiac function, with LBBB causing a decrease in stroke volume and CRT an almost complete recovery of stroke volume: meta.pv_loops([beat_baseline, beat_lbbb, beat_crt], model_names=[\"Baseline\", \"LBBB\", \"CRT\"]) Plotting the stretch reveals the typical behavior of LBBB and CRT: LBBB causes a delay in activation, increased preload, and increased work of the left free wall, while the septal contracts less and rebound stretch is noticable in several patches, however less than seen in a typical ultrasound or MRI. CRT mostly recovers these effects towards baseline: meta.stretch(beat_baseline, fig_size=(4, 3), y_lim=(0.8, 1.2)) meta.stretch(beat_lbbb, fig_size=(4, 3), legend=False, y_lim=(0.8, 1.2)) meta.stretch(beat_crt, fig_size=(4, 3), legend=False, y_lim=(0.8, 1.2))","title":"Example 3: Activation timing"},{"location":"single_beats/#references","text":"[1] Oomen, P. J. A., Phung, T.-K. N., Weinberg, S. H., Bilchick, K. C. & Holmes, J. W. A rapid electromechanical model to predict reverse remodeling following cardiac resynchronization therapy. Biomech Model Mechan 21, 231\u2013247 (2022). [2] Lumens, J., Delhaas, T., Kirn, B. & Arts, T. Three-Wall Segment (TriSeg) Model Describing Mechanics and Hemodynamics of Ventricular Interaction. Ann Biomed Eng 37, 2234\u20132255 (2009). [3] Walmsley, J. et al. Fast Simulation of Mechanical Heterogeneity in the Electrically Asynchronous Heart Using the MultiPatch Module. Plos Comput Biol 11, e1004284 (2015).","title":"References"}]}